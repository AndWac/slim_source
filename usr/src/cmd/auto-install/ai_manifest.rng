<?xml version="1.0" encoding="UTF-8"?>
<!--
CDDL HEADER START

The contents of this file are subject to the terms of the
Common Development and Distribution License (the "License").
You may not use this file except in compliance with the License.

You can obtain a copy of the license at usr/src/OPENSOLARIS.LICENSE
or http://www.opensolaris.org/os/licensing.
See the License for the specific language governing permissions
and limitations under the License.

When distributing Covered Code, include this CDDL HEADER in each
file and include the License file at usr/src/OPENSOLARIS.LICENSE.
If applicable, add the following below this CDDL HEADER, with the
fields enclosed by brackets "[]" replaced with your own identifying
information: Portions Copyright [yyyy] [name of copyright owner]

CDDL HEADER END

Copyright 2010 Sun Microsystems, Inc.  All rights reserved.
Use is subject to license terms.
-->

<!--
===============================================================================
RelaxNG schema for Automatic Installer input manifest specification.

Contains schema rules and content specification for AI manifest.

===============================================================================
-->


<grammar
    xmlns="http://relaxng.org/ns/structure/1.0"
    datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">

        <start>
                <element name="ai_manifest">
			<attribute name="name"/>
                        <!-- General automatic Installation parameters -->
                        <ref name="auto_installation_manifest"/>
                </element>
        </start>

        <!--
        =======================================================================
        Parameters used for Automatic installation
        =======================================================================
        -->
        <define name="auto_installation_manifest">
                <interleave>      <!-- Any element order is OK. -->
			<optional>
                		<element name="ai_target_device">
					<ref name="ai_target_device_contents"/>
				</element>
			</optional>
		
			<zeroOrMore>
                		<element name="ai_device_partitioning">
					<ref name="ai_device_partitioning_contents"/>
				</element>
			</zeroOrMore>
		
			<zeroOrMore>
                		<element name="ai_device_vtoc_slices">
					<ref name="ai_device_vtoc_slices_contents"/>
				</element>
			</zeroOrMore>
			
			<optional>
                		<element name="ai_device_zfs_root_pool">
					<ref name="ai_zfs_root_pool_contents"/>
				</element>
			</optional>
		
			<optional>
				<element name="ai_swap_device">
					<ref name="ai_swap_device_contents"/>
				</element>
			</optional>

			<optional>
				<element name="ai_dump_device">
					<ref name="ai_dump_device_contents"/>
				</element>
			</optional>

			<optional>
				<choice>
					<element name="ai_pkg_repo_default_publisher">
						<ref name="ai_pkg_repo_contents"/>
					</element>
					<element name="ai_pkg_repo_default_authority">
						<ref name="ai_pkg_repo_contents"/>
					</element>
				</choice>
			</optional>

			<zeroOrMore>
				<choice>
					<element name="ai_pkg_repo_addl_publisher">
						<ref name="ai_pkg_repo_contents"/>
					</element>
					<element name="ai_pkg_repo_addl_authority">
						<ref name="ai_pkg_repo_contents"/>
					</element>
				</choice>
			</zeroOrMore>

			<!--
			========================================================
			Define AI packages
			========================================================
			-->
			<choice>
				<element name="ai_packages">
					<zeroOrMore>
						<element name="package_name">
							<text/>
						</element>
					</zeroOrMore>
				</element>

				<element name="ai_install_packages">
					<oneOrMore>
						<element name="pkg">
							<attribute name="name">
								<text/>
							</attribute>
						</element>
					</oneOrMore>
				</element> 
			</choice>

			<optional>
				<element name="ai_uninstall_packages">
					<oneOrMore>
						<element name="pkg">
							<attribute name="name">
								<text/>
							</attribute>
						</element>
					</oneOrMore>
				</element>
			</optional>

			<optional>
				<element name="ai_http_proxy">
					<ref name="ai_http_proxy_contents"/>
				</element>
			</optional>

			<optional>
				<element name="ai_auto_reboot">
					<data type="boolean"/>
				</element>
			</optional>		
		</interleave>
	</define>

        <!--
        =======================================================================
        Selections for AI target Device specification

	Disk criteria are divided into two mutually exclusive groups:

	G1 - deterministic disk criteria
	................................
	  * iscsi_target_parameters
	  * target_device_name (c#t#d# name or 'boot_disk')
	  * target_device_select_volume_name
	  * target_device_select_id
	  * target_device_select_device_path

	G2 - rest of disk criteria
	..........................
	  * target_device_type
	  * target_device_vendor
	  * target_device_size

	Schema enforces following policy:

	* criteria in group G1 are mutually exclusive - only
	  one can be specified at a time

	* groups G1 and G2 are mutually exclusive - i.e.
	  if criteria from G1 is specified, no criteria
	  from G2 are allowed and vice versa

	* multiple criteria from G2 can be specified
        =======================================================================
        -->
        <define name="ai_target_device_contents">
		<interleave>
			<choice>
				<ref name="iscsi_target_parameters"/>
	                	<!--
				    c#t#d# device name like c0t0d0 or 
				    MPXIO name like c0t2000002037CD9F72d0
				    or 'boot_disk' keyword to select boot disk
				-->
				<element name="target_device_name">
					<text/>
				</element>

	                	<!-- volume name set for instance by means
				    of format(1M) command -->
				<element name="target_device_select_volume_name">
					<text/>
				</element>

	                	<!-- device id - e.g. can be obtained by means of
				    iostat(1M) -iEn -->
                       		<element name="target_device_select_id">
					<text/>
				</element>

	                	<!-- device path under /devices directory, e.g.
				    /pci@1e,600000/pci@0/pci@9/pci@0/scsi@1/sd@0,0 -->
                       		<element name="target_device_select_device_path">
					<text/>
				</element>
				<group>
					<interleave>
						<optional>
							<element name="target_device_type">
								<text/>
							</element>
						</optional>
						<optional>
							<element name="target_device_vendor">
								<text/>
							</element>
						</optional>
						<optional>
							<element name="target_device_size">
								<text/>
							</element>
						</optional>
					</interleave>
				</group>
			</choice>
			<optional>
				<element name="target_device_install_slice_number">
					<choice>
						<value>0</value>
						<value>1</value>
						<value>2</value>
						<value>3</value>
						<value>4</value>
						<value>5</value>
						<value>6</value>
						<value>7</value>
					</choice>
				</element>
			</optional>
			<optional>
				<element name="target_device_use_solaris_partition">
					<data type="boolean"/>
				</element>
			</optional>
			<optional>
				<element name="target_device_overwrite_root_zfs_pool">
					<data type="boolean"/>
				</element>
			</optional>
		</interleave>
	</define>

        <!--
        =======================================================================
	iSCSI boot parameters - target IP and name are mandatory
        =======================================================================
        -->
        <define name="iscsi_target_parameters">
		<interleave>
			<optional>
				<element name="target_device_iscsi_parameter_source">
					<text/>
				</element>
			</optional>
			<optional>
				<interleave>
					<element name="target_device_iscsi_target_name">
						<text/>
					</element>
					<element name="target_device_iscsi_target_ip">
						<text/>
					</element>
					<optional>
						<element name="target_device_iscsi_target_lun">
							<text/>
						</element>
					</optional>
					<optional>
						<element name="target_device_iscsi_target_port">
							<data type="unsignedLong"/>
						</element>
					</optional>
				</interleave>
			</optional>
		</interleave>
	</define>

        <!--
        =======================================================================
        Selections for AI target device partitions specification
        =======================================================================
        -->
        <define name="ai_device_partitioning_contents">
		<choice>
			<group>
				<interleave>
					<element name="partition_action">
						<value>delete</value>
					</element>
					<choice> <!-- delete partition -->
						<group> <!-- by partition number -->
							<interleave>
								<ref name="partition_number_contents"/>
								<optional>
									<ref name="partition_size_contents"/>
								</optional>
								<optional>
									<ref name="partition_start_sector_contents"/>
								</optional>
								<optional>
									<ref name="partition_size_units_contents"/>
								</optional>
								<optional>
									<ref name="partition_type_contents"/>
								</optional>
								<optional>
									<ref name="partition_is_logical_contents"/>
								</optional>
							</interleave>
						</group>
						<group> <!-- by starting sector and optionally size/units -->
							<interleave>
								<ref name="partition_start_sector_contents"/>
								<optional>
									<ref name="partition_size_contents"/>
								</optional>
								<optional>
									<ref name="partition_size_units_contents"/>
								</optional>
								<optional>
									<ref name="partition_number_contents"/>
								</optional>
								<optional>
									<ref name="partition_type_contents"/>
								</optional>
								<optional>
									<ref name="partition_is_logical_contents"/>
								</optional>
							</interleave>
						</group>
					</choice>
				</interleave>
			</group>
			<group> <!-- create partition by size with optional units, ID, starting sector, primary/logical -->
				<interleave>
					<element name="partition_action">
						<value>create</value>
					</element>
					<ref name="partition_size_contents"/>
					<optional>
						<ref name="partition_size_units_contents"/>
					</optional>
					<optional>
						<ref name="partition_type_contents"/>
					</optional>
					<optional>
						<ref name="partition_start_sector_contents"/>
					</optional>
					<optional>
						<ref name="partition_is_logical_contents"/>
					</optional>
					<optional>
						<ref name="partition_number_contents"/>
					</optional>
				</interleave>
			</group>
		</choice>
	</define>
        <define name="partition_number_contents">
		<element name="partition_number">
			<data type="unsignedByte"/>
		</element>
	</define>
        <define name="partition_size_contents">
		<element name="partition_size">
			<!-- integer or "max_size" to use largest free region -->
			<choice>
				<data type="unsignedLong"/>
				<value>max_size</value>
				<value>MAX_SIZE</value>
			</choice>
		</element>
	</define>
        <define name="partition_start_sector_contents">
                 <element name="partition_start_sector">
			<data type="long"/>
		</element>
	</define>
        <define name="partition_size_units_contents">
		<element name="partition_size_units">
			<ref name="disk_space_size_units"/>
		</element>
	</define>
        <define name="partition_type_contents">
		<element name="partition_type">
			<text/>
		</element>
	</define>
        <define name="partition_is_logical_contents">
		<element name="partition_is_logical">
			<data type="boolean"/>
		</element>
	</define>
        <!--
        =======================================================================
        Selections for AI target device vtoc slices specification
        =======================================================================
        -->
        <define name="ai_device_vtoc_slices_contents">
		<choice>
			<!-- create slice, providing number, size and optionally units -->
			<group>
				<interleave>
					<element name="slice_action">
						<value>create</value>
					</element>
					<ref name="slice_number_contents"/>
					<ref name="slice_size_contents"/>
					<optional>
						<ref name="slice_size_units_contents"/>
					</optional>
				</interleave>
			</group>
			<!-- delete slice - by slice number only -->
			<group>
				<interleave>
					<element name="slice_action">
						<value>delete</value>
					</element>
					<ref name="slice_number_contents"/>
					<optional>
						<ref name="slice_size_contents"/>
					</optional>
					<optional>
						<ref name="slice_size_units_contents"/>
					</optional>
				</interleave>
			</group>
			<!-- preserve slice - by slice number only -->
			<group>
				<interleave>
					<element name="slice_action">
						<value>preserve</value>
					</element>
					<ref name="slice_number_contents"/>
					<optional>
						<ref name="slice_size_contents"/>
					</optional>
					<optional>
						<ref name="slice_size_units_contents"/>
					</optional>
				</interleave>
			</group>
		</choice>
	</define>
	<define name="slice_number_contents">
		<element name="slice_number">
			<data type="unsignedByte"/>
		</element>
	</define>
	<define name="slice_size_contents">
              	<element name="slice_size">
			<!-- integer or "max_size" to use largest free region -->
			<choice>
				<data type="unsignedLong"/>
				<value>max_size</value>
				<value>MAX_SIZE</value>
			</choice>
		</element>
	</define>
        <define name="slice_size_units_contents">
		<element name="slice_size_units">
			<ref name="disk_space_size_units"/>
		</element>
	</define>

        <!--
        =======================================================================
        Selections for AI ZFS Root Pool specification
        =======================================================================
        -->
        <define name="ai_zfs_root_pool_contents">
		<interleave>
			<optional>
                       		<element name="enable_mirrored_root">
					<data type="boolean"/>
				</element>
			</optional>
			<optional>
                       		<element name="zfs_options">
					<text/>
				</element>
			</optional>
		</interleave>
	</define>

        <!--
        =======================================================================
        Selections for AI swap specification
	The target device will be used as swap device
        =======================================================================
        -->
        <define name="ai_swap_device_contents">
               <element name="ai_swap_size">
			<data type="unsignedLong"/>
		</element>
	</define>

        <!--
        =======================================================================
        Selections for AI dump specification
	The target device will be used as dump device
        =======================================================================
        -->
        <define name="ai_dump_device_contents">
               <element name="ai_dump_size">
			<data type="unsignedLong"/>
		</element>
	</define>

        <!--
        =======================================================================
        Define a publisher and its mirror backups.
        =======================================================================
        -->
        <define name="ai_pkg_repo_contents">
                <element name="main">
                        <ref name="ai_repo_name"/>
                </element>
                <zeroOrMore>
                        <element name="mirror">
                                <ref name="ai_mirror_name"/>
                        </element>
                </zeroOrMore>
        </define>

	<define name="ai_repo_name">
		<choice>
			<attribute name="publisher">
				<text/>
			</attribute>
			<attribute name="authname">
				<text/>
			</attribute>
		</choice>
		<attribute name="url">
			<text/>
		</attribute>
	</define>

	<define name="ai_mirror_name">
		<attribute name="url">
			<text/>
		</attribute>
	</define>	

        <!--
        =======================================================================
        Define AI proxy
        =======================================================================
        -->
	<define name="ai_http_proxy_contents">
		<attribute name="url">
			<text/>
		</attribute>
	</define>	
        <!--
        =======================================================================
        General definitions
        =======================================================================
        -->
        <!--
        =======================================================================
        Units measuring sizable regions of space on disk drives
        =======================================================================
        -->
        <define name="disk_space_size_units">
		<choice>
			<value>sectors</value>	<!-- disk space sectors (512 bytes) -->
			<value>secs</value>
			<value>sec</value>
			<value>s</value>
			<value>megabytes</value>
			<value>megabyte</value>
			<value>mib</value>
			<value>mb</value>
			<value>m</value>
			<value>gigabytes</value>
			<value>gigabyte</value>
			<value>gib</value>
			<value>gb</value>
			<value>g</value>
			<value>terabytes</value>
			<value>terabyte</value>
			<value>tib</value>
			<value>tb</value>
			<value>t</value>
			<value>SECTORS</value>	<!-- disk space sectors (512 bytes) -->
			<value>SECS</value>
			<value>SEC</value>
			<value>S</value>
			<value>MEGABYTES</value>
			<value>MEGABYTE</value>
			<value>MIB</value>
			<value>MiB</value>
			<value>MB</value>
			<value>M</value>
			<value>GIGABYTES</value>
			<value>GIGABYTE</value>
			<value>GIB</value>
			<value>GiB</value>
			<value>GB</value>
			<value>G</value>
			<value>TERABYTES</value>
			<value>TERABYTE</value>
			<value>TIB</value>
			<value>TiB</value>
			<value>TB</value>
			<value>T</value>
		</choice>
	</define>

</grammar>
